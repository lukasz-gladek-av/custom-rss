<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>maGaming RSS Feed - gamedeveloper_com</title>
        <link>https://lukasz-gladek-av.github.io/custom-rss/gamedeveloper_com.xml</link>
        <description>A cleaned-up version of the original gaming feed for gamedeveloper_com</description>
        <lastBuildDate>Wed, 15 Jan 2025 18:24:39 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Converting saves, a cross platform journey]]></title>
            <link>https://www.gamedeveloper.com/programming/save-the-saves</link>
            <guid>https://www.resetera.com/threads/converting-saves-a-cross-platform-journey.1083021/</guid>
            <content:encoded><![CDATA[https://www.gamedeveloper.com/programming/save-the-saves<br/><br/><div id="readability-page-1" class="page"><div data-module="content" data-testid="article-base-body-content"><p data-testid="content-paragraph"><span data-testid="content-text">The case we’re about to discuss is none other than the beautiful and critically acclaimed </span><span data-testid="content-text"><span>The Star Named EOS.</span></span><span data-testid="content-text"> In this article about console porting, we’ll discuss specifically the solutions we found to translate the save system. Without further ado, let’s jump right in..</span></p><p data-testid="content-paragraph"><span data-testid="content-text">In </span><span data-testid="content-text"><span>The Star Named EOS,</span></span><span data-testid="content-text"> the system operations are performed directly and synchronously without a hint of asynchronous interaction. This is quite an exciting task that presents many challenges. For example, PlayStation 5 works with saves through memory mount, which does not happen instantly. The critical point is that the saves will only be completed by unmounting the memory area. In fact, for PlayStation, you can use PlayerPrefs, which works similarly to memory mount, but all of this happens behind the scenes, out of our control. However, this approach has a significant drawback — the available memory volume is limited since the primary purpose of this feature is to save game settings. Therefore, the limits are pretty expected. However, since screenshots are used for saves, this limit will be insufficient, so the first save option remains primary.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">What about Xbox? Xbox currently uses GDK API as the main one, and to use it at the start of the project, synchronization with cloud data always takes place. This already affects another element of the project — initialization. But that’s not what we are here to discuss. The main idea of working with saves on Xbox is that each time you write or read, you need to open a container, perform the necessary operations, notify the GDK API about the changes (if any), and close the container.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">What about the Switch? It is almost the same as on PlayStation: mounting and unmounting take time.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">How is data saved in the original game we are working on? Saves are created as follows: data is saved, a screenshot of the screen is taken, and it is recorded in the save. Each time a save is deleted or a new one is created, the data is reread.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">We created a unified save system for this project as a single entry point for any platform. Each platform has its own SDK and methods for working with saves, so creating a unified system became essential for ensuring consistency. As a result, we made a single entry point script that works using the Adapter pattern and controls entities for each platform, determining which platform is in use and running the appropriate script.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">Now, we have a more or less complete picture of our main challenges. What are they?</span></p><div data-component="basic-list"><ol data-testid="basic-list-ordered"><li><div><p data-testid="content-paragraph"><span data-testid="content-text">The project code must be able to release the main thread without breaking the core execution logic.</span></p></div></li><li><div><p data-testid="content-paragraph"><span data-testid="content-text">We need to minimize the number of calls to our save system, as even asynchronous calls can cause freezes.</span></p></div></li><li><div><p data-testid="content-paragraph"><span data-testid="content-text">Since we have asynchronous calls, we must ensure the main condition — only one call to the save system at a time.</span></p></div></li></ol></div><p data-testid="content-paragraph"><span data-testid="content-text">A simple and quite effective solution is to use Task. Async. Why? Because it allows you to pause the original logic and resume it when needed. Is this the best solution in terms of project performance? No. Will it provide the fastest and most expected result? Yes.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">Of course, this approach generates much additional code after compilation, but it gives us precisely the expected result. Now, we need to remove all direct calls to the file system and replace them with new calls to the "new save system implementation" that we developed on Task. Async.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">After that, we rework all methods that call our save system methods to async so they can pause their execution until all save or load actions are completed. We also partially rework higher-level methods in the call hierarchy if necessary. Thus, the first most critical issue has been resolved.</span></p><p>A screenshot of The Star Named EOS. Image via Pingle Studio.</p><p data-testid="content-paragraph"><span data-testid="content-text">What next?</span></p><p data-testid="content-paragraph"><span data-testid="content-text">At this stage, we encountered an issue with Unity’s “Player Prefs.” To address it, we created a custom analog that works similarly but saves data to a file, allowing it to be used on any platform, including Switch. This solution was necessary because Nintendo Switch does not support Unity “Player Prefs” and can only save using the native Nintendo SDK.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">Then, we had to minimize calls to the save system. The original project was implemented as follows: We have an analog of PlayerPrefs that is written to a file—a dictionary with save names that are used to access screenshots and save data. Every time reading, writing, or deleting files occurs, they are read from scratch. On PCs, especially with SSDs, this is not a problem, so optimization can be ignored, but on consoles with more than a dozen saves, this can lead to serious problems.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">There are several solutions to this problem:</span></p><div data-component="basic-list"><ul data-testid="basic-list-unordered"><li><div><p data-testid="content-paragraph"><span data-testid="content-text">Bundle a large amount of data and access the saves with a batch of operations (which requires reworking the original logic and may take a lot of time).</span></p></div></li><li><div><p data-testid="content-paragraph"><span data-testid="content-text">Create a cache for already loaded saves and use cached data for repeated access.</span></p></div></li></ul></div><p data-testid="content-paragraph"><span data-testid="content-text">The second option was much more convenient to implement, so we chose it as the main one. It does not create additional interaction scenarios when there are dozens rewrites of one object or simultaneous read-and-write operations. Such situations might not be very obvious, but avoiding them from the start is better so they do not become a significant challenge later on.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">So, we have one final challenge left — multiple simultaneous write, read, and delete operations. This is pretty easy to manage when using asynchronous calls. Each time we are about to work with a file, we can use an indicator, such as a semaphore or a simple variable that signals that the queue is still busy. Since we reworked the original logic for Task, async, our code awaits further calls, and a simple variable where we do an increment when the save operation starts and a decrement when it ends is sufficient. This way, we can ensure that multiple operations do not happen simultaneously, and the interaction logic eliminates competition at the entry point.</span></p><p data-testid="content-paragraph"><span data-testid="content-text">Hope you’ve had a good read and maybe learn something. Until next time...</span></p></div></div>]]></content:encoded>
        </item>
    </channel>
</rss>